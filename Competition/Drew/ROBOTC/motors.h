#pragma config(Motor,  port1,           dBackRight,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           dBackLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           dFrontRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           dFrontLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftLower,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftUpper,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           piston,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           piston_adjuster, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Globals.
//Damn I wish ROBOTC had encapsulation
#define MAX_SPEED 127
#define MIN_SPEED 1
#define NO_SPEED 0
bool liftOn = false;
bool firing = false;

/*
Fire the piston only if the lift is on and feeding,
hopefully this will make sure that the robot only
shoots when a ball is coming. One thing I need to
add to robot/code is a way to check that we have a
ball loaded.
*/
//void firePiston(float length)
//{
//	motor[piston] = MAX_SPEED;
//	wait1Msec(length);
//	motor[piston] = NO_SPEED;
//}


void singleJoystick() { //Yeah, this is arcade drive
	motor[dBackLeft] = (vexRT[Ch2] + vexRT[Ch1]) / 2;
	motor[dFrontLeft] = (vexRT[Ch2] + vexRT[Ch1]) / 2;
	motor[dBackRight] = (vexRT[Ch2] - vexRT[Ch1]) / 2;
	motor[dFrontRight] = (vexRT[Ch2] - vexRT[Ch1]) / 2;
}

void dualJoystick() {
	motor[dBackLeft] = vexRT[Ch4];
	motor[dFrontLeft] = vexRT[Ch4];
	motor[dBackRight] = vexRT[Ch2];
	motor[dFrontRight] = vexRT[Ch2];
}

void mapJoystick() {

	singleJoystick(); //single joystick control

	//Toggle lift
	if(vexRT[Btn7L] == 1) { // For testing purposes, setting to main controller
		liftOn = !liftOn;
		}else if(liftOn){
		motor[liftLower] = MAX_SPEED;
		motor[liftUpper] = MAX_SPEED;
		motor[intake] = MAX_SPEED;
		}else if(!liftOn){
		motor[liftLower] = NO_SPEED;
		motor[liftUpper] = NO_SPEED;
		motor[intake] = NO_SPEED;
	}

	//Toogle piston
	if(vexRT[Btn7R] == 1){
		firing = !firing;
		}else if(firing){
		motor[piston] = MAX_SPEED;
		}else if(!firing){
		motor[piston] = NO_SPEED;
	}

	//Fine tuning adjustment for piston
	motor[piston_adjuster] = vexRT[Ch4];

}
// I like organization! :B1:
