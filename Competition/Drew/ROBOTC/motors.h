#pragma config(Motor,  port1,           dBackLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           dBackRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           dFrontRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           dFrontLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftLower,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftUpper,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           piston,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Globals.
//Damn I wish ROBOTC had encapsulation
#define TRUE 1
#define FALSE 0
#define MAX_SPEED 127
#define MIN_SPEED 1
#define NO_SPEED 0
bool liftOn = false;


/*
 Fire the piston only if the lift is on and feeding,
 hopefully this will make sure that the robot only
 shoots when a ball is coming. One thing I need to
 add to robot/code is a way to check that we have a
 ball loaded.
*/
void firePiston(float length)
{
	if(!liftOn)
		return;

	motor[piston] = MAX_SPEED;
	wait1Msec(length);
	motor[piston] = NO_SPEED;
}


void singleJoystick() { //Yeah, this is arcade drive
	motor[dBackLeft] = (vexRT[Ch2] + vexRT[Ch1]) / 2;
	motor[dFrontLeft] = (vexRT[Ch2] + vexRT[Ch1]) / 2;
	motor[dBackRight] = (vexRT[Ch2] - vexRT[Ch1]) / 2;
	motor[dFrontRight] = (vexRT[Ch2] - vexRT[Ch1]) / 2;
}

void dualJoystick() {
	motor[driveLeft] = vexRT[Ch2];
	motor[driveRight] = vexRT[Ch4];
}

void mapJoystick() {

	singleJoystick(); //single joystick control

	//Toggle lift
	if(vexRT[Btn7LXmtr2] == TRUE || liftOn) {
		motor[liftLower] = MAX_SPEED;
		motor[liftUpper] = MAX_SPEED;
		liftOn = !liftOn;
		}else if(!liftOn){
		motor[liftLower] = NO_SPEED;
		motor[liftUpper] = NO_SPEED;
	}

	if(vexRT[Btn7RXmtr2] == 1){
		firePiston(2000);
	}
}
// I like organization! :B1:
